# -*- coding: utf-8 -*-

from distutils.version import StrictVersion
from typing import Optional

import pretty_bad_protocol as gnupg
import os
import io
import re
import scrypt
from random import SystemRandom

from base64 import b32encode
from datetime import date
from flask import current_app
from pretty_bad_protocol._util import _is_stream, _make_binary_stream
from redis import Redis
from typing import List

from typing import Dict

import rm

from models import Source
from passphrases import DicewarePassphrase


# monkey patch to work with Focal gnupg.
# https://github.com/isislovecruft/python-gnupg/issues/250
gnupg._parsers.Verify.TRUST_LEVELS["DECRYPTION_COMPLIANCE_MODE"] = 23

# to fix GPG error #78 on production
os.environ['USERNAME'] = 'www-data'

# SystemRandom sources from the system rand (e.g. urandom, CryptGenRandom, etc)
# It supplies a CSPRNG but with an interface that supports methods like choice
random = SystemRandom()

# safe characters for every possible word in the wordlist includes capital
# letters because codename hashes are base32-encoded with capital letters
DICEWARE_SAFE_CHARS = (' !#%$&)(+*-1032547698;:=?@acbedgfihkjmlonqpsrutwvyxzA'
                       'BCDEFGHIJKLMNOPQRSTUVWXYZ')


def monkey_patch_delete_handle_status(
    self: gnupg._parsers.DeleteResult, key: str, value: str
) -> None:
    """
    Parse a status code from the attached GnuPG process.
    :raises: :exc:`~exceptions.ValueError` if the status message is unknown.
    """
    if key in ("DELETE_PROBLEM", "KEY_CONSIDERED"):
        self.status = self.problem_reason.get(value, "Unknown error: %r" % value)
    elif key in ("PINENTRY_LAUNCHED"):
        self.status = key.replace("_", " ").lower()
    else:
        raise ValueError("Unknown status message: %r" % key)


# Monkey patching to resolve https://github.com/freedomofpress/securedrop/issues/4294
gnupg._parsers.DeleteResult._handle_status = monkey_patch_delete_handle_status


class CryptoException(Exception):
    pass


class CryptoUtil:

    GPG_KEY_TYPE = "RSA"

    # All reply keypairs will be "created" on the same day SecureDrop (then
    # Strongbox) was publicly released for the first time.
    # https://www.newyorker.com/news/news-desk/strongbox-and-aaron-swartz
    DEFAULT_KEY_CREATION_DATE = date(2013, 5, 14)

    # '0' is the magic value that tells GPG's batch key generation not
    # to set an expiration date.
    DEFAULT_KEY_EXPIRATION_DATE = '0'

    REDIS_FINGERPRINT_HASH = "sd/crypto-util/fingerprints"
    REDIS_KEY_HASH = "sd/crypto-util/keys"

    SOURCE_KEY_UID_RE = re.compile(r"(Source|Autogenerated) Key <[-A-Za-z0-9+/=_]+>")

    def __init__(self,
                 scrypt_params: Dict[str, int],
                 scrypt_id_pepper: str,
                 scrypt_gpg_pepper: str,
                 securedrop_root: str,
                 nouns_file: str,
                 adjectives_file: str,
                 gpg_key_dir: str) -> None:
        self.__securedrop_root = securedrop_root

        if os.environ.get('SECUREDROP_ENV') in ('dev', 'test'):
            # Optimize crypto to speed up tests (at the expense of security
            # DO NOT use these settings in production)
            self.__gpg_key_length = 1024
            self.scrypt_params = dict(N=2**1, r=1, p=1)
        else:  # pragma: no cover
            self.__gpg_key_length = 4096
            self.scrypt_params = scrypt_params

        self.scrypt_id_pepper = scrypt_id_pepper
        self.scrypt_gpg_pepper = scrypt_gpg_pepper

        self.do_runtime_tests()

        # --pinentry-mode, required for SecureDrop on GPG 2.1.x+, was
        # added in GPG 2.1.
        self.gpg_key_dir = gpg_key_dir
        gpg_binary = gnupg.GPG(binary='gpg2', homedir=self.gpg_key_dir)
        if StrictVersion(gpg_binary.binary_version) >= StrictVersion('2.1'):
            self.gpg = gnupg.GPG(binary='gpg2',
                                 homedir=gpg_key_dir,
                                 options=['--pinentry-mode loopback'])
        else:
            self.gpg = gpg_binary

        with io.open(nouns_file) as f:
            self.nouns = f.read().splitlines()

        with io.open(adjectives_file) as f:
            self.adjectives = f.read().splitlines()

        self.redis = Redis(decode_responses=True)

    # Make sure these pass before the app can run
    def do_runtime_tests(self) -> None:
        if self.scrypt_id_pepper == self.scrypt_gpg_pepper:
            raise AssertionError('scrypt_id_pepper == scrypt_gpg_pepper')
        # crash if we don't have a way to securely remove files
        if not rm.check_secure_delete_capability():
            raise AssertionError("Secure file deletion is not possible.")

    def display_id(self) -> str:
        """Generate random journalist_designation until we get an unused one"""

        tries = 0

        while tries < 50:
            new_designation = ' '.join([random.choice(self.adjectives),
                                        random.choice(self.nouns)])

            collisions = Source.query.filter(Source.journalist_designation == new_designation)
            if collisions.count() == 0:
                return new_designation

            tries += 1

        raise ValueError("Could not generate unique journalist designation for new source")

    def hash_codename(self, codename: DicewarePassphrase, salt: Optional[str] = None) -> str:
        """Salts and hashes a codename using scrypt.

        :param codename: A source's codename.
        :param salt: The salt to mix with the codename when hashing.
        :returns: A base32 encoded string; the salted codename hash.
        """
        if salt is None:
            salt = self.scrypt_id_pepper
        return b32encode(scrypt.hash(codename, salt, **self.scrypt_params)).decode('utf-8')

    def genkeypair(self, name: str, secret: DicewarePassphrase) -> gnupg._parsers.GenKey:
        """Generate a GPG key through batch file key generation. A source's
        codename is salted with SCRYPT_GPG_PEPPER and hashed with scrypt to
        provide the passphrase used to encrypt their private key. Their name
        should be their filesystem id.

        >>> if not gpg.list_keys(hash_codename('randomid')):
        ...     genkeypair(hash_codename('randomid'), 'randomid').type
        ... else:
        ...     u'P'
        u'P'

        :param name: The source's filesystem id (their codename, salted
                         with SCRYPT_ID_PEPPER, and hashed with scrypt).
        :param secret: The source's codename.
        :returns: a :class:`GenKey <gnupg._parser.GenKey>` object, on which
                  the ``__str__()`` method may be called to return the
                  generated key's fingeprint.

        """
        _validate_name_for_diceware(name)
        hashed_secret = self.hash_codename(secret, salt=self.scrypt_gpg_pepper)
        genkey_obj = self.gpg.gen_key(self.gpg.gen_key_input(
            key_type=self.GPG_KEY_TYPE,
            key_length=self.__gpg_key_length,
            passphrase=hashed_secret,
            name_email=name,
            name_real="Source Key",
            creation_date=self.DEFAULT_KEY_CREATION_DATE.isoformat(),
            expire_date=self.DEFAULT_KEY_EXPIRATION_DATE
        ))
        return genkey_obj

    def find_source_key(self, fingerprint: str) -> Optional[Dict]:
        """
        Searches the GPG keyring for a source key.

        A source key has the given fingerprint and is labeled either
        "Source Key" or "Autogenerated Key".

        Returns the key or None.
        """
        keys = self.gpg.list_keys()
        for key in keys:
            if fingerprint != key["fingerprint"]:
                continue

            for uid in key["uids"]:
                if self.SOURCE_KEY_UID_RE.match(uid):
                    return key
                else:
                    return None
        return None

    def delete_reply_keypair(self, source_filesystem_id: str) -> None:
        fingerprint = self.get_fingerprint(source_filesystem_id)

        if not fingerprint:
            return

        # verify that the key with the given fingerprint belongs to a source
        key = self.find_source_key(fingerprint)
        if not key:
            raise ValueError("source key not found")

        # Always delete keys without invoking pinentry-mode = loopback
        # see: https://lists.gnupg.org/pipermail/gnupg-users/2016-May/055965.html
        temp_gpg = gnupg.GPG(binary='gpg2', homedir=self.gpg_key_dir, options=["--yes"])

        # The subkeys keyword argument deletes both secret and public keys.
        temp_gpg.delete_keys(fingerprint, secret=True, subkeys=True)
        self.redis.hdel(self.REDIS_KEY_HASH, self.get_fingerprint(source_filesystem_id))
        self.redis.hdel(self.REDIS_FINGERPRINT_HASH, source_filesystem_id)

    def get_fingerprint(self, name: str) -> Optional[str]:
        """
        Returns the fingerprint of the GPG key for the given name.

        The supplied name is usually a source filesystem ID.
        """
        fingerprint = self.redis.hget(self.REDIS_FINGERPRINT_HASH, name)
        if fingerprint:
            return fingerprint

        for key in self.gpg.list_keys():
            for uid in key['uids']:
                if name in uid:
                    self.redis.hset(self.REDIS_FINGERPRINT_HASH, name, key['fingerprint'])
                    return key['fingerprint']

        return None

    def get_pubkey(self, name: str) -> Optional[str]:
        """
        Returns the GPG public key for the given name.

        The supplied name is usually a source filesystem ID.
        """
        fingerprint = self.get_fingerprint(name)
        if not fingerprint:
            return None

        key = self.redis.hget(self.REDIS_KEY_HASH, fingerprint)
        if key:
            return key

        key = self.gpg.export_keys(fingerprint)
        self.redis.hset(self.REDIS_KEY_HASH, fingerprint, key)
        return key

    def encrypt(self, plaintext: str, fingerprints: List[str], output: Optional[str] = None) -> str:
        # Verify the output path
        if output:
            current_app.storage.verify(output)

        # Remove any spaces from provided fingerprints GPG outputs fingerprints
        # with spaces for readability, but requires the spaces to be removed
        # when using fingerprints to specify recipients.
        fingerprints = [fpr.replace(' ', '') for fpr in fingerprints]

        if not _is_stream(plaintext):
            plaintext = _make_binary_stream(plaintext, "utf_8")

        out = self.gpg.encrypt(plaintext,
                               *fingerprints,
                               output=output,
                               always_trust=True,
                               armor=False)
        if out.ok:
            return out.data
        else:
            raise CryptoException(out.stderr)

    def decrypt(self, secret: DicewarePassphrase, ciphertext: bytes) -> str:
        """
        >>> crypto = current_app.crypto_util
        >>> key = crypto.genkeypair('randomid', 'randomid')
        >>> message = u'Buenos dÃ­as, mundo hermoso!'
        >>> ciphertext = crypto.encrypt(message, str(key))
        >>> crypto.decrypt('randomid', ciphertext) == message.encode('utf-8')
        True
        """
        hashed_codename = self.hash_codename(secret,
                                             salt=self.scrypt_gpg_pepper)
        data = self.gpg.decrypt(ciphertext, passphrase=hashed_codename).data

        return data.decode('utf-8')


def _validate_name_for_diceware(name: str) -> None:
    for char in name:
        if char not in DICEWARE_SAFE_CHARS:
            raise CryptoException("invalid input: {0}".format(name))
