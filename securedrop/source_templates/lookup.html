{% extends "base.html" %}

{% block body %}
{% if new_user_codename %}
<details class="code-reminder pull-left" id="codename-hint">
  <summary>{{ gettext('Remember, your codename is:') }}</summary>
  <mark class="codename">{{ new_user_codename }}</mark>
</details>
{% endif %}

<div class="center">
  {% include 'flashed.html' %}
</div>

<section aria-labelledby="submit-heading">
  {% if allow_document_uploads %}
  <h2 id="submit-heading" class="headline">{{ gettext('Submit Files or Messages') }}</h2>
  <p class="explanation">{{ gettext('You can submit any kind of file, a message, or both.') }}</p>
  {% else %}
  <h2 id="submit-heading" class="headline">{{ gettext('Submit Messages') }}</h2>
  {% endif %}
<!--<button id="generate"></button>-->

<script type="module">
  import init, { SecureDropSourceSession } from '/static/js/securedrop_source.js';

  async function run() {
    await init();

    // As soon as wasm is loaded, we begin key generation if it's not done yet.
    const needs_registration = JSON.parse("{{ to_register }}".toLowerCase());
    const source_uuid = "{{ source_uuid }}";
    const securedrop_group = "{{ securedrop_group }}";

    // TODO: TEMP ONLY
    const token = "{{ token }}"

    console.log(`we need to register: ${needs_registration}`);
    var session = SecureDropSourceSession.new(source_uuid);

    if (needs_registration == true) {
      var keygen_data = session.generate();
      console.log(`signal key generation succeeded: ${keygen_data}`);
      // TODO: If keygen_success is false, then we'd need to show some sort of error to the user.
      var request = new XMLHttpRequest();
      request.open("POST", "http://127.0.0.1:8080/api/v2/register", true);
      request.setRequestHeader("Content-Type", "application/json");
      request.setRequestHeader("Authorization", `Token ${token}`);

      request.onreadystatechange = function () {
        if (request.readyState === 4 && request.status === 200) {
          console.log("registered successfully!")
        }
      };
      request.send(JSON.stringify(keygen_data));

      // Todo when we have multiple journalists
      // For each journalist for which we do not have prekeys:
      // But for now the group is a single journalist.
      var journalist_uuid = securedrop_group;

      var prekey_request = new XMLHttpRequest();
      prekey_request.open("GET", `http://127.0.0.1:8080/api/v2/journalists/${journalist_uuid}/prekey_bundle`, true);
      prekey_request.setRequestHeader("Content-Type", "application/json");
      prekey_request.setRequestHeader("Authorization", `Token ${token}`);

      prekey_request.onreadystatechange = function () {
        if (prekey_request.readyState === 4 && prekey_request.status === 200) {
          var prekey_data = JSON.parse(this.response)
          console.log(`got some ${prekey_data}`)

          // TODO: show error to user if the below call fails
          session.process_prekey_bundle(
            prekey_data["registration_id"],
            prekey_data["identity_key"],
            prekey_data["journalist_uuid"],
            prekey_data["signed_prekey_id"],
            prekey_data["signed_prekey"],
            prekey_data["prekey_signature"]
            );
          console.log("processed prekey bundle successfully");

          document.getElementById("submit-doc-button").disabled = false;
        }
      };
      prekey_request.send();
    } else {
      document.getElementById("submit-doc-button").disabled = false;
    }

    console.log(`user is registered, waiting for message send`);

    const submitButton = document.getElementById("submit-doc-button");
    submitButton.addEventListener("click", event => {
      // Clear success message so we can see it succeed again
      if (document.getElementById("success-message")) {
        document.getElementById("success-message").value = "";
      }

      var message_text = document.getElementById("message-input").value;
      // TODO: Don't do anything if message empty
      var ciphertext = session.encrypt(journalist_uuid, message_text);
      console.log(`message text: ${message_text}`);
      console.log(`ciphertext: ${ciphertext}`);

      var submit_request = new XMLHttpRequest();
      submit_request.open("POST", `http://127.0.0.1:8080/api/v2/journalists/${journalist_uuid}/messages`, true);
      submit_request.setRequestHeader("Content-Type", "application/json");
      submit_request.setRequestHeader("Authorization", `Token ${token}`);

      submit_request.onreadystatechange = function () {
        if (submit_request.readyState === 4 && submit_request.status === 200) {
          const success_div = document.createElement("div");
          success_div.id = "success-message"
          const success_emoji = document.createTextNode("sent! ✅");
          success_div.appendChild(success_emoji);
          document.getElementById("below-the-submit").prepend(success_div);
          setTimeout(removeSendMsg, 3000); // Remove this message in 3 seconds
          console.log("sent successfully!")
        }
      };
      submit_request.send(JSON.stringify({
        "message": ciphertext,
      }));

      // Now reset UI for next message
      document.getElementById("message-input").value = "";
      });

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Temp: Investigate best way to sanitize plaintext messages prior to display
    function sanitizeString(str) {
      str = str.replace(/[^a-z0-9áéíóúñü \.,_-]/gim,"");
      return str.trim();
    }

    function removeSendMsg() {
      document.getElementById("success-message").remove();
    }

    while (true) {
      // Download
      var request = new XMLHttpRequest();
      request.open("GET", "http://127.0.0.1:8080/api/v2/messages", true);
      request.setRequestHeader("Content-Type", "application/json");
      request.setRequestHeader("Authorization", `Token ${token}`);

      request.onreadystatechange = function () {
        if (request.readyState === 4 && request.status === 200) {
          var reply_data = JSON.parse(this.response);

          if (reply_data["resp"] == 'NEW_MSG') {
            console.log("got new reply");
            var plaintext = session.decrypt(
              reply_data["journalist_uuid"],
              reply_data["message"],
              );
            console.log(`decrypted new message!: ${plaintext}`);
            // At this point, we might want to store messages somewhere more persistent
            // (e.g. some browser storage that works while in Private Browsing Mode).
            // Otherwise, when a user refreshes, their messages will be gone.

            // Security note: at this point we need to sanitize the plaintext prior to
            // displaying in the browser. For now we use sanitizeString, but we may
            // want to bring in another dependency for this.
            const reply_div = document.createElement("div");
            reply_div.className = "reply";
            const success_blquote = document.createElement("blockquote");
            success_blquote.textContent = sanitizeString(plaintext);
            reply_div.appendChild(success_blquote);
            document.getElementById("replies").appendChild(reply_div);

            // Now send confirmation.
            var message_uuid = reply_data["message_uuid"];
            var confirm = new XMLHttpRequest();
            confirm.open("POST", `http://127.0.0.1:8080/api/v2/messages/confirmation/${message_uuid}`, true);
            confirm.setRequestHeader("Content-Type", "application/json");
            confirm.setRequestHeader("Authorization", `Token ${token}`);
            confirm.onreadystatechange = function () {
              console.log(`sent confirmation of message ${message_uuid} on server`);
            }
            confirm.send();
          }
        }
      };
      request.send();

      // Wait
      await sleep(15000);
    }
  }

  run();
</script>
<!-- TODO: Your fingerprint is X -->

  <p class="explanation extended-explanation">
    {% if allow_document_uploads %}
    {{ gettext('If you are already familiar with GPG, you can optionally encrypt your files and messages with our <a href="{url}" class="text-link">public key</a> before submission. Files are encrypted as they are received by SecureDrop.').format(url=url_for('info.download_public_key')) }}
    {% else %}
    {{ gettext('If you are already familiar with GPG, you can optionally encrypt your messages with our <a href="{url}" class="text-link">public key</a> before submission.').format(url=url_for('info.download_public_key')) }}
    {% endif %}
    {{ gettext('<a href="{url}" class="text-link">Learn more</a>.').format(url=url_for('info.why_download_public_key')) }}
  </p>

    <input name="csrf_token" type="hidden" value="{{ csrf_token() }}">
    <div class="snippet">
      {% if allow_document_uploads %}
      <div class="attachment grid-item center">
        <span class="fh">{{ form.fh(**{"aria-describedby": "max-file-size"}) }}</span>
        <p class="center" id="max-file-size">{{ gettext('Maximum upload size: 500 MB') }}</p>
      </div>
      {% endif %}
      <div class="message grid-item{% if not allow_document_uploads %} wide{% endif %}">
        {{ form.msg(class="fill-parent") }}
      </div>
    </div>

    <div class="pull-right" id="below-the-submit">
      <button type="submit" id="submit-doc-button" aria-label="{{ gettext('Submit') }}">
        {{ gettext('SUBMIT') }}
      </button>



      <a href="{{ url_for('main.lookup') }}" class="btn secondary" id="cancel" role="button"
        aria-label="{{ gettext('Cancel') }}">
        {{ gettext('CANCEL') }}
      </a>
    </div>
</section>

<section aria-labelledby="replies-heading">
  <h2 id="replies-heading" class="headline">{{ gettext('Responses') }}</h2>

  <div id="replies">
    <aside>
      <p>{{ gettext("When you receive a reply, to protect your identity in the unlikely event someone learns your codename, your replies will disappear after your session ends. You can respond by submitting new files and messages above.") }}</p>
    </aside>
      <hr class="no-line">
      <!--{% for reply in replies %}
        <div class="reply">
          <blockquote>{{ reply.decrypted | nl2br }}</blockquote>
          <div class="clearfix"></div>
        </div>
      {% endfor %}-->
  </div>
</section>

{% endblock %}
