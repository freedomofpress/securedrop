#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""A utility to update our Python dependencies while avoiding dependency
version conflicts between them.
"""

import argparse
import collections
import os
import shutil
import string
import subprocess
import tempfile

working_dir = os.path.dirname(os.path.realpath(__file__))
testinfra_dir = os.path.join(working_dir, 'testinfra')
app_reqs_dir = os.path.join(working_dir, 'securedrop/requirements')
tmp_reqs_dir = tempfile.mkdtemp()

testinfra = {}
testinfra['in'] = os.path.join(testinfra_dir, 'requirements.in')
testinfra['txt'] = os.path.join(testinfra_dir, 'requirements.txt')
testinfra['tmp_in'] = os.path.join(tmp_reqs_dir, 'testinfra-reqs.in')
testinfra['tmp_txt'] = os.path.join(tmp_reqs_dir, 'testinfra-reqs.txt')

sd = {}
sd['in'] = os.path.join(app_reqs_dir, 'securedrop-requirements.in')
sd['txt'] = os.path.join(app_reqs_dir, 'securedrop-requirements.txt')
sd['tmp_txt'] = os.path.join(tmp_reqs_dir, 'sd-reqs.txt')

test = {}
test['in'] = os.path.join(app_reqs_dir, 'test-requirements.in')
test['txt'] = os.path.join(app_reqs_dir, 'test-requirements.txt')
test['tmp_in'] = os.path.join(tmp_reqs_dir, 'test-reqs.in')
test['tmp_txt'] = os.path.join(tmp_reqs_dir, 'test-reqs.txt')

develop = {}
develop['in'] = os.path.join(app_reqs_dir, 'develop-requirements.in')
develop['txt'] = os.path.join(app_reqs_dir, 'develop-requirements.txt')
develop['tmp_in'] = os.path.join(tmp_reqs_dir, 'develop-reqs.in')
develop['tmp_txt'] = os.path.join(tmp_reqs_dir, 'develop-reqs.txt')

reqs_pref_order = collections.OrderedDict()
reqs_pref_order['securedrop'] = sd
reqs_pref_order['test'] = test
reqs_pref_order['testinfra'] = testinfra
reqs_pref_order['develop'] = develop


def create_reqs_dict(file):
    """Parses a requirements.txt file generated by `pip-compile` with
    and returns a dict mapping dependency names (keys) to versions
    (vals).
    """
    reqs = {}
    with open(file) as fh:
        for line in fh:
            if line[0] in string.ascii_letters:
                name, version = line.rstrip('\n').split('==')
                name = name.lower()
                version = version.split(' ')[0]
                reqs[name] = version
    return reqs


def pip_compile(in_file, txt_file):
    """Invokes pip-compile, which unfortunately does not provide an API.
    """
    # pip-compile expects the destination to exist for whatever reason.
    if not os.path.exists(txt_file):
        open(txt_file, 'w').close()
    if pip_compile.upgrade:
        subprocess.check_call(['pip-compile', '--upgrade', '--no-header',
                               '-o', txt_file, in_file])
    else:
        subprocess.check_call(['pip-compile', '--no-header',
                               '-o', txt_file, in_file])


def append_shared_dependencies(req):
    """When the `req` shares lower or top-level dependencies with any of
    the other requirements lists that are considered to be of greater
    importance, it appends the versions of those shared dependencies
    from the preferred requirements lists' .txt file to the temporary
    .in file of `req`. This way, when the temporary .in file of `req` is
    compiled to produce the .txt file of `req`, there will be no
    conflicts with any of the requirements files that are preferred over
    `req`.
    """
    rank = reqs_pref_order.values().index(req)
    unpreferred_reqs = create_reqs_dict(req['tmp_txt'])
    with open(req['tmp_in'], 'a') as fh:
        for preferred_req in reqs_pref_order.values()[:rank]:
            preferred_reqs = create_reqs_dict(preferred_req['txt'])
            for req_name, req_version in preferred_reqs.items():
                if req_name in unpreferred_reqs.keys():
                    fh.write(req_name + '==' + req_version + '\n')


def compile_compatibly_with_preferred_reqs(req):
    """Does a straightforward compile of a `req`'s .in file to a
    temporary .txt file. Then copies that `req`'s .in file to a
    temporary .in file. Next, any lower or top-level dependencies `req`
    shares with the requirements files preferred to it are appended to
    that temporary .in file. Finally, the temporary .in file is compiled
    to produce the requirements.txt file for that `req`.
    """
    pip_compile(req['in'], req['tmp_txt'])
    shutil.copyfile(req['in'], req['tmp_in'])
    append_shared_dependencies(req)
    pip_compile(req['tmp_in'], req['tmp_txt'])
    # Do not overwrite .txt files if only the comments pip-compile creates have
    # changed.
    if create_reqs_dict(req['tmp_txt']) != create_reqs_dict(req['txt']):
        shutil.copyfile(req['tmp_txt'], req['txt'])


def verify():
    """Creates a set of all the unique (dependency, version) tuples from
    all our requirements.txt files, and asserts that we don't see two
    version of the same dependency in that set.
    """
    all_reqs = set()
    for req in reqs_pref_order.values():
        for dep_vers in create_reqs_dict(req['txt']).items():
            all_reqs.add(dep_vers)

    unique_deps = []
    for dep_vers in list(all_reqs):
        assert dep_vers[0] not in unique_deps, ('Conflicting dependencies'
                                                'detected!')
        unique_deps.append(dep_vers[0])


def main(file):
    """We simply compile our requirements file of greatest importance,
    the SecureDrop app code requirements. For the rest of our
    requirements files, this function sequentially "compatibility
    compiles" each requirements files such that there will be no
    conflicts in the final .txt requirements files. When requirements
    files share lower or top-level dependencies with each other, the
    version requested by doing a straightforward compile of the
    left-most element of `reqs_pref_order` will be standardized upon in
    all the final requirements.txt files.
    """
    assert file in reqs_pref_order.keys(), ('Argument to file must be in '
                                            '{}.'.format(
                                                reqs_pref_order.keys()))
    if file == 'sd':
        pip_compile(sd['in'], sd['tmp_txt'])
        # Do not overwrite .txt files if only the comments pip-compile creates have
        # changed.
        if create_reqs_dict(sd['tmp_txt']) != create_reqs_dict(sd['txt']):
            shutil.copyfile(sd['tmp_txt'], sd['txt'])

    rank = max(reqs_pref_order.keys().index(file), 1)
    for req in reqs_pref_order.values()[rank:]:
        compile_compatibly_with_preferred_reqs(req)

    verify()

def get_args():
    parser = argparse.ArgumentParser(prog=__file__, description=__doc__)
    parser.add_argument('--upgrade', action='store_true', help='Upgrade all '
                        'requirements lists to use the latest dependency '
                        'versions possible while maintaining compatibility '
                        'between them.')
    parser.add_argument('--file', default='securedrop', help='To keep '
                        'updates as granular as possible, specify the in '
                        'file you made changes to.')
    return parser

if __name__ == '__main__':
    args = get_args().parse_args()
    pip_compile.upgrade = args.upgrade
    main(args.file)
